---
description: This rule explains Feature-Sliced Design (FSD) architecture conventions and best practices for scalable frontend applications.
globs: **/*.js,**/*.jsx,**/*.ts,**/*.tsx
alwaysApply: true
---

# Feature-Sliced Design (FSD) Architecture Rules

## Layer Structure

- Follow the strict 7-layer hierarchy: `shared` ‚Üí `entities` ‚Üí `features` ‚Üí `widgets` ‚Üí `pages` ‚Üí
  `processes` ‚Üí `app`
- Each layer can only import from layers below it (upward imports are forbidden)
- Use kebab-case for all directory names: `user-profile`, `auth-form`, `order-history`

## Segment Organization

- Structure each slice with standard segments: `ui/`, `model/`, `api/`, `lib/`, `config/`
- Export everything through `index.ts` files (Public API principle)
- Keep internal implementation details private within segments

## Import Rules

- ‚ùå **Never** import from upper layers: `features` cannot import from `widgets`
- ‚ùå **Never** import across slices at the same level: `features/auth` cannot import from
  `features/cart`
- ‚úÖ **Always** use Public API: import from `index.ts` files only
- ‚úÖ **Cross-communication** between same-level slices only through `shared` layer

## File Naming Conventions

- **Directories**: kebab-case (`user-settings/`, `product-card/`)
- **Components**: PascalCase files (`UserProfile.tsx`, `ProductCard.tsx`)
- **Utilities/Hooks**: camelCase (`useAuth.ts`, `formatDate.ts`)
- **Constants**: UPPER_SNAKE_CASE (`API_ENDPOINTS.ts`, `ERROR_MESSAGES.ts`)

## Layer-Specific Rules

### `shared/` - Common Infrastructure

- Contains reusable UI components, utilities, configurations
- No business logic or feature-specific code
- Examples: `shared/ui/button/`, `shared/lib/utils/`, `shared/api/base/`

### `entities/` - Business Entities

- Domain models and their basic operations
- Examples: `entities/user/`, `entities/product/`, `entities/order/`
- Focus on data structures and simple CRUD operations

### `features/` - User Interactions

- Complete user scenarios and business features
- Examples: `features/auth/`, `features/add-to-cart/`, `features/product-search/`
- Each feature should be independent and self-contained

### `widgets/` - Composite UI Blocks

- Complex UI compositions combining multiple features/entities
- Examples: `widgets/header/`, `widgets/product-list/`, `widgets/user-dashboard/`

### `pages/` - Route Components

- Application pages and routing logic
- Examples: `pages/home/`, `pages/product/`, `pages/profile/`
- Should compose widgets and features, minimal logic

### `app/` - Application Setup

- App initialization, global providers, routing setup
- Examples: `app/providers/`, `app/styles/`, `app/store/`

## Next.js Integration

- Place Next.js route files in `pages/` layer following App Router structure
- Use `app/` layer for Next.js configuration and providers
- Server Components in `entities/` and `features/` for data fetching
- Client Components should be minimal and wrapped with `'use client'`

## State Management

- Keep local state within feature segments
- Share global state only through `shared/` layer
- Use proper state management tools (Zustand, Redux, etc.) in `shared/model/`

## Testing Structure

- Mirror FSD structure in test directories
- Unit tests alongside components: `features/auth/__tests__/`
- Integration tests in dedicated test layers

## Component Decomposition Rules

### Fine-Grained Component Separation

- **Maximum Granularity**: Break down components into the smallest possible units
- **Single Responsibility**: Each component should have one clear purpose
- **Reusability Focus**: Extract any reusable UI elements into separate components
- **Layer-Based Organization**: Organize decomposed components according to FSD layers

### Component Decomposition Strategy

1. **UI Primitives** ‚Üí `shared/ui/` (buttons, inputs, icons, decorations)
2. **Business Components** ‚Üí `entities/` (user cards, product items)
3. **Feature Components** ‚Üí `features/` (forms, interactive elements)
4. **Composite Components** ‚Üí `widgets/` (complex UI blocks)
5. **Page Components** ‚Üí `pages/` (route-level compositions)

### Logic Decomposition Rules

### Fine-Grained Logic Separation

- **Atomic Functions**: Break logic into smallest functional units
- **Hook Extraction**: Extract reusable state logic into custom hooks
- **Service Layer**: Separate business logic from UI components
- **Utility Functions**: Extract pure functions into utility modules

### Logic Decomposition Strategy

1. **Pure Utilities** ‚Üí `shared/lib/` (formatters, validators, helpers)
2. **Custom Hooks** ‚Üí `shared/model/` or feature-specific `model/`
3. **API Logic** ‚Üí `shared/api/` or entity-specific `api/`
4. **Business Logic** ‚Üí `entities/*/model/` or `features/*/model/`
5. **Configuration** ‚Üí `shared/config/` or layer-specific `config/`

### Shared Layer Guidelines

#### ‚ö†Ô∏è **Don't Rush to Shared**

- **Start Specific**: Begin with feature-specific or entity-specific implementations
- **Prove Reusability**: Only move to `shared/` after **3+ actual reuse cases**
- **Avoid Premature Optimization**: Don't predict future sharing needs

#### ‚úÖ **What Belongs in Shared**

- **Truly Generic** utilities (date formatting, validation, etc.)
- **Framework-level** components (basic Button, Input, Modal)
- **Cross-domain** logic used by multiple business domains
- **Technical** infrastructure (API clients, logging, etc.)

#### ‚ùå **What Should NOT be in Shared**

- **Domain-specific** logic (invitation-specific animations)
- **Business-specific** UI components (beauty-themed decorations)
- **Single-use** utilities that might be reused someday
- **Themed** components tied to specific design systems

### Decomposition Examples

#### Before (Monolithic)

```
app/invite/page.tsx (500+ lines)
```

#### After (Decomposed)

```
widgets/beauty-invitation/
  ui/EnvelopeInvitation.tsx
  ui/DiamondCenterpiece.tsx
  ui/LuxuryBorder.tsx
  model/useEnvelopeAnimation.ts

features/invitation-swipe/
  ui/SwipeToOpen.tsx
  model/useSwipeGesture.ts

features/invitation-code/
  ui/InvitationCodeInput.tsx
  model/useInvitationCode.ts

entities/invitation/
  ui/DiamondSeal.tsx
  ui/LuxuryBackground.tsx
  model/invitationTypes.ts

shared/ui/
  button/Button.tsx
  input/TextInput.tsx
  icon/ArrowIcon.tsx
```

## Import Path Guidelines

### ‚úÖ **Absolute Paths Preferred**

- **Always use absolute paths** for imports instead of relative paths
- **Consistent structure**: All imports should start from the project root
- **Better maintainability**: Easier to refactor and move files
- **Clearer dependencies**: Absolute paths make layer relationships explicit

#### Examples:

```typescript
// ‚úÖ Good - Absolute paths
import { Button } from 'shared/ui/button';
import { useAuth } from 'features/auth/model/useAuth';
import { UserCard } from 'entities/user/ui/UserCard';
import { Header } from 'widgets/header/ui/Header';

// ‚ùå Bad - Relative paths
import { Button } from '../../../shared/ui/button';
import { useAuth } from '../../features/auth/model/useAuth';
import { UserCard } from '../entities/user/ui/UserCard';
```

### üîß **TypeScript Path Mapping**

Configure `tsconfig.json` with baseUrl and paths:

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "shared/*": ["shared/*"],
      "entities/*": ["entities/*"],
      "features/*": ["features/*"],
      "widgets/*": ["widgets/*"],
      "pages/*": ["pages/*"],
      "app/*": ["app/*"]
    }
  }
}
```

## Code Reusability and DRY Principles

### ‚úÖ **Eliminate Code Duplication**

- **Constants & Configuration**: Extract repeated values into shared constants
- **Type Definitions**: Share common types across the application
- **Utility Functions**: Centralize reusable logic
- **Component Patterns**: Abstract common UI patterns

### Duplication Elimination Strategy

1. **Constants** ‚Üí `shared/config/` (API endpoints, locales, themes)
2. **Types** ‚Üí `shared/model/types/` (common interfaces, enums)
3. **Utilities** ‚Üí `shared/lib/` (formatters, validators, helpers)
4. **Components** ‚Üí `shared/ui/` (reusable UI elements)

### Examples:

#### ‚ùå **Before (Duplicated)**

```typescript
// Multiple files with repeated locale values
const locales = ['en', 'ko', 'th']; // in middleware.ts
const locales = ['en', 'ko', 'th']; // in dictionaries.ts
const languages = [
  { code: 'en', name: 'English' },
  { code: 'ko', name: 'ÌïúÍµ≠Ïñ¥' },
  { code: 'th', name: '‡πÑ‡∏ó‡∏¢' },
]; // in LanguageSwitcher.tsx
```

#### ‚úÖ **After (Centralized)**

```typescript
// shared/config/locales.ts
export const SUPPORTED_LOCALES = ['en', 'ko', 'th'] as const;
export type Locale = (typeof SUPPORTED_LOCALES)[number];
export const DEFAULT_LOCALE: Locale = 'en';

export const LOCALE_LABELS: Record<Locale, string> = {
  en: 'English',
  ko: 'ÌïúÍµ≠Ïñ¥',
  th: '‡πÑ‡∏ó‡∏¢',
};
```

### Configuration Management Rules

- **Single Source of Truth**: One file per configuration domain
- **Type Safety**: Use TypeScript const assertions and derived types
- **Environment Awareness**: Separate dev/prod configurations
- **Validation**: Validate configuration at startup

## Common Anti-Patterns to Avoid

- ‚ùå Circular dependencies between layers
- ‚ùå Direct cross-slice imports at same level
- ‚ùå Business logic in `shared/` layer
- ‚ùå UI components in `entities/` layer
- ‚ùå Bypassing Public API (index.ts files)
- ‚ùå **Monolithic components** over 200 lines
- ‚ùå **Mixed responsibilities** in single component/function
- ‚ùå **Logic coupled** to specific UI components
- ‚ùå **Premature shared extraction** without proven reuse
- ‚ùå **Domain-specific code** in shared layer
- ‚ùå **Over-abstraction** of single-use components
- ‚ùå **Relative import paths** (use absolute paths instead)
- ‚ùå **Duplicated constants** across multiple files
- ‚ùå **Hardcoded values** without centralized configuration

## API Structure Guidelines

### ÌîºÏ≤òÎ≥Ñ API Íµ¨Ï°∞

ÌäπÏ†ï ÌîºÏ≤òÏùò API ÏóîÎìúÌè¨Ïù∏Ìä∏Îäî Ìï¥Îãπ ÌîºÏ≤ò Ìè¥Îçî ÎÇ¥Ïóê ÏúÑÏπòÌï¥Ïïº Ìï©ÎãàÎã§:

```
features/
  invitation-code/
    api/                     # API Í≥ÑÏ∏µ
      entities/             # ÎèÑÎ©îÏù∏ ÏóîÌã∞Ìã∞
        types.ts            # ÎèÑÎ©îÏù∏ ÌÉÄÏûÖ Ï†ïÏùò
        schemas.ts          # ÏûÖÎ†• Í≤ÄÏ¶ù Ïä§ÌÇ§Îßà
      infrastructure/       # Ïù∏ÌîÑÎùº Í≥ÑÏ∏µ
        repositories/       # Îç∞Ïù¥ÌÑ∞ Ïï°ÏÑ∏Ïä§ Í≥ÑÏ∏µ
          invite-code-repository.ts
        services/           # Ïù∏ÌîÑÎùº ÏÑúÎπÑÏä§ Í≥ÑÏ∏µ
          invite-code-validation-service.ts
      use-cases/            # Ïú†Ïä§ÏºÄÏù¥Ïä§ Í≥ÑÏ∏µ
        validate-invite-code.ts
        types.ts            # Ïú†Ïä§ÏºÄÏù¥Ïä§ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§
      route.ts              # ÎùºÏö∞Ìä∏ Ìï∏Îì§Îü¨
```

### Í≥µÌÜµ API Ïú†Ìã∏Î¶¨Ìã∞ Í≥µÏú†

#### ‚úÖ **Shared LayerÏóê Í≥µÌÜµ API Ïú†Ìã∏Î¶¨Ìã∞ Î∞∞Ïπò**

Ïó¨Îü¨ ÌîºÏ≤òÏóêÏÑú Í≥µÌÜµÏúºÎ°ú ÏÇ¨Ïö©ÎêòÎäî API Í¥ÄÎ†® Ïú†Ìã∏Î¶¨Ìã∞Îäî `shared/lib/api/`Ïóê Î∞∞Ïπò:

```typescript
// shared/lib/api/error-handlers.ts
export function redirectToErrorPage(
  requestUrl: string,
  errorCode: string,
  provider?: string,
): NextResponse {
  const baseUrl = new URL(requestUrl).origin;
  const errorUrl = new URL('/auth/error', baseUrl);
  errorUrl.searchParams.set('error', errorCode);
  if (provider) {
    errorUrl.searchParams.set('provider', provider);
  }

  return NextResponse.redirect(errorUrl);
}

// shared/lib/api/response-helpers.ts
export function createSuccessResponse<T>(data: T): NextResponse {
  return NextResponse.json({ success: true, data });
}

export function createErrorResponse(error: string, status: number = 400): NextResponse {
  return NextResponse.json({ success: false, error }, { status });
}
```

#### ‚úÖ **ÌîºÏ≤òÎ≥Ñ APIÏóêÏÑú Í≥µÌÜµ Ïú†Ìã∏Î¶¨Ìã∞ ÌôúÏö©**

```typescript
// features/line-auth/api/line-callback-handler.ts
import { redirectToErrorPage } from 'shared/lib/api/error-handlers';

export async function handleLineCallback(request: NextRequest): Promise<NextResponse> {
  try {
    // ... ÎπÑÏ¶àÎãàÏä§ Î°úÏßÅ
  } catch (error) {
    return redirectToErrorPage(request.url, 'LINE_AUTH_ERROR', 'line');
  }
}

// app/[lang]/(auth-app)/auth/callback/route.ts
import { redirectToErrorPage } from 'shared/lib/api/error-handlers';

export async function GET(request: Request) {
  try {
    // ... ÎπÑÏ¶àÎãàÏä§ Î°úÏßÅ
  } catch (error) {
    return redirectToErrorPage(request.url, 'AUTH_CODE_ERROR');
  }
}
```

#### ‚ùå **Ï§ëÎ≥µÎêú ÏóêÎü¨ Ìï∏Îì§ÎßÅ ÏΩîÎìú**

```typescript
// ‚ùå Í∞Å ÌîºÏ≤òÎßàÎã§ Ï§ëÎ≥µÎêú ÏóêÎü¨ Ìï∏Îì§ÎßÅ
function redirectToErrorPage(requestUrl: string, errorCode: string): NextResponse {
  const baseUrl = new URL(requestUrl).origin;
  const errorUrl = new URL('/auth/error', baseUrl);
  errorUrl.searchParams.set('error', errorCode);
  return NextResponse.redirect(errorUrl);
}
```

### ÌÅ¥Î¶∞ ÏïÑÌÇ§ÌÖçÏ≤ò ÏõêÏπô Ï†ÅÏö©

- **Entities**: ÎèÑÎ©îÏù∏ ÏóîÌã∞Ìã∞ Î∞è ÎπÑÏ¶àÎãàÏä§ Í∑úÏπô
- **Use Cases**: Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò ÎπÑÏ¶àÎãàÏä§ Î°úÏßÅ
- **Interface Adapters**: Ïª®Ìä∏Î°§Îü¨, Í≤åÏù¥Ìä∏Ïõ®Ïù¥, ÌîÑÎ†àÏ††ÌÑ∞
- **Frameworks & Drivers**: Ïô∏Î∂Ä ÎùºÏù¥Î∏åÎü¨Î¶¨, Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§, Ïõπ ÌîÑÎ†àÏûÑÏõåÌÅ¨

### Shared Layer ÏÇ¨Ïö© ÏõêÏπô

#### ‚úÖ Shared LayerÏóê Ìè¨Ìï®ÎêòÏñ¥Ïïº ÌïòÎäî Í≤É

- **ÏßÑÏ†ïÌïú Í≥µÌÜµÏÑ±**: Ïó¨Îü¨ ÌîºÏ≤òÏóêÏÑú Ïã§Ï†úÎ°ú Í≥µÏú†ÎêòÎäî ÏΩîÎìú
- **Í∏∞Ïà†Ï†Å Ïù∏ÌîÑÎùº**: Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞, Ïô∏Î∂Ä API ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏
- **Í≥µÌÜµ Ïú†Ìã∏Î¶¨Ìã∞**: ÎÇ†Ïßú Ìè¨Îß∑ÌÑ∞, Î¨∏ÏûêÏó¥ Ïú†Ìã∏Î¶¨Ìã∞ Îì±
- **Í≥µÌÜµ ÌÉÄÏûÖ**: Ï†ïÎßê Î™®Îì† Í≥≥ÏóêÏÑú ÏÇ¨Ïö©ÎêòÎäî Í∏∞Î≥∏ ÌÉÄÏûÖ

#### ‚ùå Shared LayerÏóê Ìè¨Ìï®ÎêòÏßÄ ÏïäÏïÑÏïº ÌïòÎäî Í≤É

- **ÌîºÏ≤òÎ≥Ñ ÎπÑÏ¶àÎãàÏä§ Î°úÏßÅ**: ÌäπÏ†ï Í∏∞Îä•Ïóê ÌäπÌôîÎêú ÏÑúÎπÑÏä§
- **ÌîºÏ≤òÎ≥Ñ Í≤ÄÏ¶ù Ïä§ÌÇ§Îßà**: ÌäπÏ†ï ÎèÑÎ©îÏù∏Ïóê ÌäπÌôîÎêú Ïä§ÌÇ§Îßà
- **ÌîºÏ≤òÎ≥Ñ ÌÉÄÏûÖ**: ÌäπÏ†ï ÌîºÏ≤òÏóêÏÑúÎßå ÏÇ¨Ïö©ÎêòÎäî ÌÉÄÏûÖ
- **Í∞ÄÏ†ïÎêú Ïû¨ÏÇ¨Ïö©ÏÑ±**: "Ïñ∏Ï††Í∞Ä Í≥µÏú†Îê† Ïàò ÏûàÎã§"Îäî Í∞ÄÏ†ï

### ÏΩîÎìú Ïù¥Îèô Î∞è Î¶¨Ìå©ÌÜ†ÎßÅ Í∞ÄÏù¥ÎìúÎùºÏù∏

#### 1Îã®Í≥Ñ: ÌòÑÏû¨ ÏΩîÎìú Î∂ÑÏÑù

- shared/libÏóê ÏûàÎäî Î™®Îì† ÏΩîÎìúÎ•º Í≤ÄÌÜ†
- Í∞Å ÏΩîÎìúÏùò Ïã§Ï†ú ÏÇ¨Ïö©Ï≤ò ÌååÏïÖ
- ÌîºÏ≤òÎ≥ÑÎ°ú Í∑∏Î£πÌôî

#### 2Îã®Í≥Ñ: Ï†ÅÏ†àÌïú ÏúÑÏπòÎ°ú Ïù¥Îèô

- **ÌîºÏ≤òÎ≥Ñ ÏΩîÎìú**: Ìï¥Îãπ features Ìè¥ÎçîÎ°ú Ïù¥Îèô
- **ÏßÑÏ†ïÌïú Í≥µÌÜµ ÏΩîÎìú**: sharedÏóê Ïú†ÏßÄ
- **ÏóîÌã∞Ìã∞ ÏΩîÎìú**: entities Ìè¥ÎçîÎ°ú Ïù¥Îèô

#### 3Îã®Í≥Ñ: Í≥ÑÏ∏µ Íµ¨Ï°∞ Ï†ÅÏö©

- Í∞Å ÌîºÏ≤òÏùò APIÎäî ÌÅ¥Î¶∞ ÏïÑÌÇ§ÌÖçÏ≤ò Íµ¨Ï°∞ Ï†ÅÏö©
- Repository, Service, UseCase Í≥ÑÏ∏µ Î∂ÑÎ¶¨
- ÏùòÏ°¥ÏÑ± Î∞©Ìñ• Ï§ÄÏàò

#### 4Îã®Í≥Ñ: ÌÖåÏä§Ìä∏ Î∞è Í≤ÄÏ¶ù

- Î™®Îì† import Í≤ΩÎ°ú ÏóÖÎç∞Ïù¥Ìä∏
- ÎπåÎìú Î∞è ÌÖåÏä§Ìä∏ Ïã§Ìñâ
- ÌÉÄÏûÖ Ï≤¥ÌÅ¨ ÏàòÌñâ

## ÏòàÏãú: Ï¥àÎåÄ ÏΩîÎìú Í≤ÄÏ¶ù Î¶¨Ìå©ÌÜ†ÎßÅ

### Before (Í∏∞Ï°¥ Íµ¨Ï°∞)

```
shared/
  lib/
    services/
      invite-code-validation.ts  # ‚ùå ÌîºÏ≤òÎ≥Ñ ÏΩîÎìúÍ∞Ä sharedÏóê
    validation/
      invite-code.ts             # ‚ùå ÌîºÏ≤òÎ≥Ñ Ïä§ÌÇ§ÎßàÍ∞Ä sharedÏóê

app/api/invite/validate/route.ts # shared/lib ÏßÅÏ†ë Ï∞∏Ï°∞
```

### After (Í∞úÏÑ†Îêú Íµ¨Ï°∞)

```
features/
  invitation-code/
    api/
      entities/
        schemas.ts               # ‚úÖ ÌîºÏ≤òÎ≥Ñ Ïä§ÌÇ§Îßà
        types.ts                 # ‚úÖ ÌîºÏ≤òÎ≥Ñ ÌÉÄÏûÖ
      infrastructure/
        services/
          invite-code-validation-service.ts  # ‚úÖ ÌîºÏ≤òÎ≥Ñ ÏÑúÎπÑÏä§
      use-cases/
        validate-invite-code.ts  # ‚úÖ Ïú†Ïä§ÏºÄÏù¥Ïä§
      route.ts                   # ‚úÖ ÎùºÏö∞Ìä∏ Ìï∏Îì§Îü¨

shared/
  lib/
    api/
      response.ts               # ‚úÖ Í≥µÌÜµ API Ïú†Ìã∏Î¶¨Ìã∞
    utils/                      # ‚úÖ Í≥µÌÜµ Ïú†Ìã∏Î¶¨Ìã∞
```

## TypeScript Rules

- **Never use `any` type**: Always provide specific types
- Use union types and generics for flexibility
- Define proper interfaces for all external dependencies
- Use type guards for runtime validation
